// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"ev_charging_system/model"
)

func newGun(db *gorm.DB, opts ...gen.DOOption) gun {
	_gun := gun{}

	_gun.gunDo.UseDB(db, opts...)
	_gun.gunDo.UseModel(&model.Gun{})

	tableName := _gun.gunDo.TableName()
	_gun.ALL = field.NewAsterisk(tableName)
	_gun.GunID = field.NewString(tableName, "gun_id")
	_gun.PileID = field.NewString(tableName, "pile_id")
	_gun.GunType = field.NewString(tableName, "gun_type")
	_gun.GunStatus = field.NewString(tableName, "gun_status")
	_gun.Power = field.NewString(tableName, "power")
	_gun.Voltage = field.NewFloat64(tableName, "voltage")
	_gun.Current = field.NewFloat64(tableName, "current")
	_gun.MaxCurrent = field.NewFloat64(tableName, "max_current")

	_gun.fillFieldMap()

	return _gun
}

type gun struct {
	gunDo gunDo

	ALL        field.Asterisk
	GunID      field.String
	PileID     field.String
	GunType    field.String
	GunStatus  field.String
	Power      field.String
	Voltage    field.Float64
	Current    field.Float64
	MaxCurrent field.Float64

	fieldMap map[string]field.Expr
}

func (g gun) Table(newTableName string) *gun {
	g.gunDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g gun) As(alias string) *gun {
	g.gunDo.DO = *(g.gunDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *gun) updateTableName(table string) *gun {
	g.ALL = field.NewAsterisk(table)
	g.GunID = field.NewString(table, "gun_id")
	g.PileID = field.NewString(table, "pile_id")
	g.GunType = field.NewString(table, "gun_type")
	g.GunStatus = field.NewString(table, "gun_status")
	g.Power = field.NewString(table, "power")
	g.Voltage = field.NewFloat64(table, "voltage")
	g.Current = field.NewFloat64(table, "current")
	g.MaxCurrent = field.NewFloat64(table, "max_current")

	g.fillFieldMap()

	return g
}

func (g *gun) WithContext(ctx context.Context) IGunDo { return g.gunDo.WithContext(ctx) }

func (g gun) TableName() string { return g.gunDo.TableName() }

func (g gun) Alias() string { return g.gunDo.Alias() }

func (g gun) Columns(cols ...field.Expr) gen.Columns { return g.gunDo.Columns(cols...) }

func (g *gun) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *gun) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 8)
	g.fieldMap["gun_id"] = g.GunID
	g.fieldMap["pile_id"] = g.PileID
	g.fieldMap["gun_type"] = g.GunType
	g.fieldMap["gun_status"] = g.GunStatus
	g.fieldMap["power"] = g.Power
	g.fieldMap["voltage"] = g.Voltage
	g.fieldMap["current"] = g.Current
	g.fieldMap["max_current"] = g.MaxCurrent
}

func (g gun) clone(db *gorm.DB) gun {
	g.gunDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g gun) replaceDB(db *gorm.DB) gun {
	g.gunDo.ReplaceDB(db)
	return g
}

type gunDo struct{ gen.DO }

type IGunDo interface {
	gen.SubQuery
	Debug() IGunDo
	WithContext(ctx context.Context) IGunDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGunDo
	WriteDB() IGunDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGunDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGunDo
	Not(conds ...gen.Condition) IGunDo
	Or(conds ...gen.Condition) IGunDo
	Select(conds ...field.Expr) IGunDo
	Where(conds ...gen.Condition) IGunDo
	Order(conds ...field.Expr) IGunDo
	Distinct(cols ...field.Expr) IGunDo
	Omit(cols ...field.Expr) IGunDo
	Join(table schema.Tabler, on ...field.Expr) IGunDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGunDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGunDo
	Group(cols ...field.Expr) IGunDo
	Having(conds ...gen.Condition) IGunDo
	Limit(limit int) IGunDo
	Offset(offset int) IGunDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGunDo
	Unscoped() IGunDo
	Create(values ...*model.Gun) error
	CreateInBatches(values []*model.Gun, batchSize int) error
	Save(values ...*model.Gun) error
	First() (*model.Gun, error)
	Take() (*model.Gun, error)
	Last() (*model.Gun, error)
	Find() ([]*model.Gun, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Gun, err error)
	FindInBatches(result *[]*model.Gun, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Gun) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGunDo
	Assign(attrs ...field.AssignExpr) IGunDo
	Joins(fields ...field.RelationField) IGunDo
	Preload(fields ...field.RelationField) IGunDo
	FirstOrInit() (*model.Gun, error)
	FirstOrCreate() (*model.Gun, error)
	FindByPage(offset int, limit int) (result []*model.Gun, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGunDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g gunDo) Debug() IGunDo {
	return g.withDO(g.DO.Debug())
}

func (g gunDo) WithContext(ctx context.Context) IGunDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g gunDo) ReadDB() IGunDo {
	return g.Clauses(dbresolver.Read)
}

func (g gunDo) WriteDB() IGunDo {
	return g.Clauses(dbresolver.Write)
}

func (g gunDo) Session(config *gorm.Session) IGunDo {
	return g.withDO(g.DO.Session(config))
}

func (g gunDo) Clauses(conds ...clause.Expression) IGunDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g gunDo) Returning(value interface{}, columns ...string) IGunDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g gunDo) Not(conds ...gen.Condition) IGunDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g gunDo) Or(conds ...gen.Condition) IGunDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g gunDo) Select(conds ...field.Expr) IGunDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g gunDo) Where(conds ...gen.Condition) IGunDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g gunDo) Order(conds ...field.Expr) IGunDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g gunDo) Distinct(cols ...field.Expr) IGunDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g gunDo) Omit(cols ...field.Expr) IGunDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g gunDo) Join(table schema.Tabler, on ...field.Expr) IGunDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g gunDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGunDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g gunDo) RightJoin(table schema.Tabler, on ...field.Expr) IGunDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g gunDo) Group(cols ...field.Expr) IGunDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g gunDo) Having(conds ...gen.Condition) IGunDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g gunDo) Limit(limit int) IGunDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g gunDo) Offset(offset int) IGunDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g gunDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGunDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g gunDo) Unscoped() IGunDo {
	return g.withDO(g.DO.Unscoped())
}

func (g gunDo) Create(values ...*model.Gun) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g gunDo) CreateInBatches(values []*model.Gun, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g gunDo) Save(values ...*model.Gun) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g gunDo) First() (*model.Gun, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Gun), nil
	}
}

func (g gunDo) Take() (*model.Gun, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Gun), nil
	}
}

func (g gunDo) Last() (*model.Gun, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Gun), nil
	}
}

func (g gunDo) Find() ([]*model.Gun, error) {
	result, err := g.DO.Find()
	return result.([]*model.Gun), err
}

func (g gunDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Gun, err error) {
	buf := make([]*model.Gun, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g gunDo) FindInBatches(result *[]*model.Gun, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g gunDo) Attrs(attrs ...field.AssignExpr) IGunDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g gunDo) Assign(attrs ...field.AssignExpr) IGunDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g gunDo) Joins(fields ...field.RelationField) IGunDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g gunDo) Preload(fields ...field.RelationField) IGunDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g gunDo) FirstOrInit() (*model.Gun, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Gun), nil
	}
}

func (g gunDo) FirstOrCreate() (*model.Gun, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Gun), nil
	}
}

func (g gunDo) FindByPage(offset int, limit int) (result []*model.Gun, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g gunDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g gunDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g gunDo) Delete(models ...*model.Gun) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *gunDo) withDO(do gen.Dao) *gunDo {
	g.DO = *do.(*gen.DO)
	return g
}
